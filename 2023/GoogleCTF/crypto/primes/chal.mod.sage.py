

# This file was *autogenerated* from the file chal.mod.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_131 = Integer(131); _sage_const_3391 = Integer(3391); _sage_const_3407 = Integer(3407); _sage_const_3433 = Integer(3433); _sage_const_3449 = Integer(3449); _sage_const_3457 = Integer(3457); _sage_const_3469 = Integer(3469); _sage_const_3491 = Integer(3491); _sage_const_3499 = Integer(3499); _sage_const_3527 = Integer(3527); _sage_const_3539 = Integer(3539); _sage_const_3541 = Integer(3541); _sage_const_3547 = Integer(3547); _sage_const_3581 = Integer(3581); _sage_const_3583 = Integer(3583); _sage_const_3607 = Integer(3607); _sage_const_3617 = Integer(3617); _sage_const_3623 = Integer(3623); _sage_const_3659 = Integer(3659)# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from tqdm import tqdm


def to_bits(m):
    _bin = lambda b: [_sage_const_1  if b & (_sage_const_1  << n) else _sage_const_0  for n in range(_sage_const_7 )]
    return sum([_bin(b) for b in m], [])


def gen_primes(r, n):
    primes = Primes()[:n]
    bound = prod(primes[n - r :])
    print(len(primes), primes)
    print(bound)
    return primes, next_prime(bound)


def prod_exp(p, q, b):
    print(len(p), len(b))
    print([p[i] ** b[i] for i in range(len(p))])
    return prod([p[i] ** b[i] for i in range(len(p))])
    # return prod([p[i] ^ b[i] for i in range(len(p))]) % q


def encode(r, n, m):
    p, q = gen_primes(r, n)
    return p, q, prod_exp(p, q, to_bits(m))


m = b"I have a sweet flag for you: CTF{YkDOLIStjpjP5Am1SXDt5d2r9es3b5KZP47v8rXF}"
p0, q0, x0 = encode(_sage_const_131 , _sage_const_7  * len(m), m)


target = b"YkDOLIStjpjP5Am1SXDt5d2r9es3b5KZP47v8rXF"
dummy = b"\x00" * len(target)
m = b"I have a sweet flag for you: CTF{" + dummy + b"}"
p1, q1, x1 = encode(_sage_const_131 , _sage_const_7  * len(m), m)

n = _sage_const_7  * len(m)
P = Primes()[:n]


def check(x):
    for p in P:
        if x % p == _sage_const_0 :
            x //= p
    return x == _sage_const_1 


assert x0 % x1 == _sage_const_0 
ans = x0 // x1
print(factor(ans))
assert check(ans)
assert q0 == q1

q = q0
t = (
    _sage_const_3391 
    * _sage_const_3407 
    * _sage_const_3433 
    * _sage_const_3449 
    * _sage_const_3457 
    * _sage_const_3469 
    * _sage_const_3491 
    * _sage_const_3499 
    * _sage_const_3527 
    * _sage_const_3539 
    * _sage_const_3541 
    * _sage_const_3547 
    * _sage_const_3581 
    * _sage_const_3583 
    * _sage_const_3607 
    * _sage_const_3617 
    * _sage_const_3623 
    * _sage_const_3659 
)

assert ans % t == _sage_const_0 
ans //= t
# ans *= pow(t, -1, q)
# ans %= q
print(ans)
assert ans < q
# # 後半 SIZE 個を決めうち
# SIZE = 20
# for bit in tqdm(range(1 << SIZE)):
#     t = ans
#     S = [i for i in range(SIZE) if bit >> i & 1]
#     # print([P[-s - 2] for s in S])
#     for s in S:
#         t *= pow(P[-s - 2], -1, q)
#         t %= q
#     if check(t):
#         print("found!")
#         print(t)

