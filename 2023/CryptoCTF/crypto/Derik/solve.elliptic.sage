from sage.schemes.elliptic_curves.constructor import projective_point
from Crypto.Util.number import long_to_bytes

O = [1391526622949983, 2848691279889518, 89200900157319, 31337]
C = [5960650533801939766973431801711817334521794480800845853788489396583576739362531091881299990317357532712965991685855356736023156123272639095501827949743772, 6521307334196962312588683933194431457121496634106944587943458360009084052009954473233805656430247044180398241991916007097053259167347016989949709567530079, 1974144590530162761749719653512492399674271448426179161347522113979158665904709425021321314572814344781742306475435350045259668002944094011342611452228289, 2613994669316609213059728351496129310385706729636898358367479603483933513667486946164472738443484347294444234222189837370548518512002145671578950835894451, 8127380985210701021743355783483366664759506587061015828343032669060653534242331741280215982865084745259496501567264419306697788067646135512747952351628613, 5610271406291656026350079703507496574797593266125358942992954619413518379131260031910808827754539354830563482514244310277292686031300804846114623378588204, 10543, 4]
c = 80607532565510116966388633842290576008441185412513199071132245517888982730482694498575603226192340250444218146275844981580541820190393565327655055810841864715587561905777565790204415381897361016717820490400344469662479972681922265843907711283466105388820804099348169127917445858990935539611525002789966360469324052731259957798534960845391898385316664884009395500706952606508518095360995300436595374193777531503846662413864377535617876584843281151030183895735511854

e = 3
d = (C[6] * e - O[3]) / C[7]

var('p,q,r')
X = C[0] * p - C[1] * q
Y = C[2] * q - C[3] * r
Z = C[4] * r - C[5] * p

_.<x,y,z> = QQ[]
cubic = x^3 + y^3 + z^3 - d*x*y*z

print("ok sage time")
f = EllipticCurve_from_cubic(cubic, [0, -1, 1], morphism=True)
finv = f.inverse()
E = f.codomain()
P = E.gens()[0]
R = P
print("let's go!")
counter = 0
while 1:
	xx, yy, zz = projective_point(finv(R))
	if xx <= 0: xx, yy, zz = -xx, -yy, -zz
	if yy >= 0 and zz >= 0:
		solns = solve([X == xx, Y == yy, Z == zz], p, q, r, solution_dict=True)
		for soln in solns:
			pp, qq, rr = [*map(Integer, projective_point([soln[p], soln[q], soln[r]]))]
			assert (C[0] * pp - C[1] * qq) ** e + (C[2] * qq - C[3] * rr) ** e + (C[4] * rr - C[5] * pp) ** e == d * (C[0] * pp - C[1] * qq) * (C[2] * qq - C[3] * rr) * (C[4] * rr - C[5] * pp)
			print([int(i).bit_length() for i in [pp, qq, rr]])
			if not all(i in Primes() for i in [pp, qq, rr]):
				continue
			print("flag time")
			primes = [e, d, pp, qq, rr]
			phi = prod(i-1 for i in primes)
			priv = pow(65537, -1, phi)
			print(long_to_bytes(int(pow(c, priv, prod(primes)))))
			exit(0)
	R = -R
	if counter%2: R += P
	counter += 1