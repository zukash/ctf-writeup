

# This file was *autogenerated* from the file server.mod.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_8 = Integer(8); _sage_const_1024 = Integer(1024); _sage_const_65537 = Integer(65537); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_255 = Integer(255); _sage_const_2 = Integer(2)
import os
import random
from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long
from sympy.polys.matrices import DomainMatrix
from sympy import FiniteField, Integer
import sys

sys.setrecursionlimit(_sage_const_10  ** _sage_const_8 )

# secret import
# from secret import decrypt
from flag import FLAG


size = _sage_const_1024  // _sage_const_8 
e = _sage_const_65537 


def decrypt(encflag, pq):
    enc_0, enc_1 = encflag
    p, q = pq
    n = p * q
    mat = matrix(Zmod(n), [[enc_0, enc_1], [_sage_const_0 , enc_0]])
    d = pow(e, -_sage_const_1 , n * (p - _sage_const_1 ) * (q - _sage_const_1 ))
    msg = mat ** d
    return int(msg[_sage_const_0 , _sage_const_1 ])


def pad(data, length):
    if len(data) >= length:
        raise ValueError("length of data is too large.")
    pad_data = bytes([random.randint(_sage_const_1 , _sage_const_255 ) for _ in range(length - len(data) - _sage_const_1 )])
    return pad_data + b"\x00" + data


def unpad(paddeddata):
    if b"\x00" not in paddeddata:
        raise ValueError("padding is incorrect.")
    return paddeddata[paddeddata.index(b"\x00") + _sage_const_1  :]


def keygen():
    p, q = getPrime(_sage_const_8  * size), getPrime(_sage_const_8  * size)
    n = p * q
    return ((p, q), n)


def encrypt(msgint, n):
    a = bytes_to_long(os.urandom(int(_sage_const_2  * size - _sage_const_1 )))
    # sympy.FiniteField treats non-prime modulus instance as Z/nZ
    Zmodn = FiniteField(n)
    mat = DomainMatrix([[Zmodn(a), Zmodn(msgint)], [Zmodn(_sage_const_0 ), Zmodn(a)]], (_sage_const_2 , _sage_const_2 ), Zmodn)

    enc = mat ** int(e)
    enc_0 = int(enc[_sage_const_0 , _sage_const_0 ].element.val)
    enc_1 = int(enc[_sage_const_0 , _sage_const_1 ].element.val)
    return (enc_0, enc_1)


def main():
    banner = "Welcome to matrix RSA world"
    print(banner)

    (p, q), n = keygen()

    paddedflag = pad(FLAG, _sage_const_2  * size - _sage_const_1 )
    assert unpad(paddedflag) == FLAG
    paddedflagint = bytes_to_long(paddedflag)
    encflag_0, encflag_1 = encrypt(paddedflagint, n)
    assert decrypt((encflag_0, encflag_1), (p, q)) == paddedflagint
    print("Here is encrypted flag(enc_0, enc_1):")
    print(long_to_bytes(encflag_0).hex())
    print(long_to_bytes(encflag_1).hex())

    while True:
        print("Please input encrypted message(enc_0, enc_1):")
        enc_0 = bytes_to_long(bytes.fromhex(input(">> ")))
        enc_1 = bytes_to_long(bytes.fromhex(input(">> ")))
        if enc_0 >= n or enc_1 >= n:
            print("size error")
            continue
        if (enc_0 * encflag_1 - enc_1 * encflag_0) % n == _sage_const_0 :
            print("Do not input related to encrypted flag")
            continue
        dec = decrypt((enc_0, enc_1), (p, q))
        if FLAG in long_to_bytes(dec):
            print("Do not input encrypted flag")
        else:
            print("Here is decrypted message:")
            print(long_to_bytes(int(dec)).hex())


if __name__ == "__main__":
    main()

