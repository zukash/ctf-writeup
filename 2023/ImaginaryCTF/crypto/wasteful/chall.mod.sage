from Crypto.Util.number import *

temprime = 0
e_fast = 0
phi = 0
p, q = 0, 0
d = 0


def keygen(sz):
    global temprime
    global e_fast
    global phi
    global p, q
    global d
    p = getPrime(sz // 2)  # 1024
    q = getPrime(sz // 2)  # 1024
    n = p * q  # 2048
    phi = (p - 1) * (q - 1)  # 2048
    e_fast = getPrime(sz // 2)  # 1024
    # temprimeを取得できる気がする。e_slow // n にかなり近いはず
    temprime = getPrime(sz // 3)
    e_slow = e_fast + temprime * phi  # 2730
    d = pow(e_fast, -1, phi)  # 2045
    return (n, e_slow), (n, e_fast), (n, d)


def encrypt(pub, m):
    n, e = pub
    return pow(m, e, n)


def decrypt(priv, c):
    n, d = priv
    return pow(c, d, n)


pub, pub_fast, priv = keygen(2048)
m = bytes_to_long(open("flag.txt", "rb").read().strip())
c = encrypt(pub, m)
# なぜ一致するのか：phiの倍数を足しても変化しない
assert c == encrypt(pub_fast, m)
assert decrypt(priv, c) == m
print(f"{pub = }")
print(f"{c = }")

##################prod####################
pub = (13922840822259331816327061476419085409003512519528232469661604921423111313933598569871108546042864180459201549111178812056125732062953204575105829153985440916358190133642640001059768522480269302460718708597523393249631888987925111597599833550446912844403320258488415701628616610291446078064678789122886626285576964983117608034972639529880315364530395658464093479171544352975507100901794069628879853771787404835325718642690170628943504486705897282590391844395048189949020318348859452241379637822658476872641393738097989171169214581791719140741349554748016829670973465416125341357284757048506380319235703137899963208097, 277280553454648256942834244379334472844168843473349557354045626945887508188843789771287658693103957086560979814144224475018152887866998026452048010146805033029525535857427508882228600591838528622357772029813779190474001956391284442790327418967008241712383374750163158501752035607501218757269377329115862935993211034408859090869371053922670217394364484435238584857739198196990517123089953446738914179515819217861804510588560805960014326909359351025582398395246863003472699126965102937701727970546875134667199496557865907051073237849103589853403297723219825816214258909806838856777367332603146213417602038287539276024671910161582026600672105045278321812944891449538504092047724097803562730455612681768718159973804451251572816656604960574129566605495957657313103014678987914865218770999608008584731005908772508291497450420251)
c = 3829822460565637897613746990073994763941184171034737019836828390881076647859928468862763977005814025279072259387758773244151849201650347661717265009919615554395232777636705330792559486048004076300537706604078026741727734943374711480077394341022197696120902084993991738576670236710557122356593411988288326114827264936321401579532665129353852827951354347055111972043781820183887400365339563091888343224947709711699474542183525971689156145628294192147447087789859929759168015997297169275809161690938900939934830602427271340102001253593076013316161869089892572516396348368906753304918487695981844135741146949836634949417
##########################################
n, e_slow = pub
# temprime は (e_slow, n) から復元可能
# assert e_slow // n == temprime - 1
# サイズの差が大きい変数の等式 → 連分数近似 や LLL が有効?
# assert e_slow == e_fast + temprime * phi
temprime = 1 + e_slow // n
phi_ = e_slow // temprime
print(abs(phi - phi_).bit_length())  # 340
x = var("x")
f = x ** 2 - (n - phi_ + 1) * x + n
p_, q_ = f.roots()
p_, q_ = int(p_[0]), int(q_[0])
p, q = sorted([p, q])
p_, q_ = sorted([p_, q_])
print(abs(p_ - p).bit_length())  # 340
print(abs(q_ - q).bit_length())  # 340

# → copper smith's attack が使えそう
#################
# https://inaz2.hatenablog.com/entry/2016/01/20/022936
# p = 0x00f23799c031b942026e420769b74d22fa2114428189139c43c366c6ab8367c6b3d6f821449aafb2058b0e6ed964fa0ad45fb306f96376e80823a72b58101919e50acad3b5e6d079e7ff9218ed6df6edbef536742714ce88b2e717f45af53ef0d04c89faf01c80b28e764973aba27726c85c0236e8756a865c03577722bac5e391
# q = 0x00c9d24330fa4945cfe1e5d6912d6bde0231035a1cc8d8ae67d949347b895f8d579bce2adaf37c568957b17a6564dbf80d36d81e4622ab30e02132b0155aefbd3912a27c625a9b7b05bc72217039f5aa88c20cbf9871c3228e9d80d9106f94b11c1f50c40c96862b5cd6b6f781883dd2eff80a059d3ca027af6a03edeb34a7390f
# n = p*q
# e = 3

beta = 0.5
epsilon = beta^2/7

pbits = 1024
kbits = floor(2048*(beta^2-epsilon))
# pbar = p & (2^pbits-2^kbits)
pbar = p_
print("upper %d bits (of %d bits) is given" % (pbits-kbits, pbits))

PR.<x> = PolynomialRing(Zmod(n))
f = x + pbar

# print(p)
x0 = f.small_roots(X=2^kbits, beta=0.3)[0]  # find root < 2^kbits with factor >= n^0.3
print(x0 + pbar)
p = int(x0 + pbar)
print(p)
assert n % p == 0
q = n // p
phi = (p - 1) * (q - 1)
d = pow(e_slow, -1, phi)
print(long_to_bytes(pow(c, d, n)))
###############


# LLL → うまくいかず
# M = matrix([[-temprime, e_slow], [0, 1]])
# print(M.transpose().LLL())
# print(e_fast)
# print(temprime)

# 連分数近似 → うまくいかず
# d * e_slow = 1 + k * phi
# d * e_slow ~= k * n
# n / e_slow ~= d / k
# cf = continued_fraction(n / e_slow)
# cand = []
# for conv in cf.convergents():
#     d = conv.numerator()
#     k = conv.denominator()
#     if d == 0:
#         continue
#     # d * e = k * (n - p - q + 1) + 1
#     # p + q = n - (d * e - 1) / k + 1
#     p_q = n - (d * e_slow - 1) / k + 1
#     if not p_q.is_integer():
#         continue
#     # (x - p) * (x - q) = 0 の解が p,q
#     # x^2 - (p + q) * x + n = 0 の解が p,q
#     cand.append(d)
#     print(pow(c, d, n) == m)
