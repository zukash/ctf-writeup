from Crypto.Util.number import *
from mpmath import mp

# flag = int.from_bytes(open("flag.txt", "rb").read().strip(), "big")

tf = (
    -0.7578486465144361653056740883647981074157721568235263947812770328593706155446273431983003083023944193451634501133844062222318380912228469321984711771640337084400211818130699382144693337133198331117688092846455855532799303682791981067718891947573941091671581719597626862194794682042719495503282817868258547714
)

alpha = arctan(tf)
print(alpha)
# flag == alpha + pi * k
# k = (flag - alpha) / pi
# assert mp.almosteq(k, round(k), eps)
# これが知りたい値
# print(round(k))

# alpha の小数点以下は306桁
# 10**306 倍して整数で考える
# 10 ** 306 を法として 0 になるような k を考える
# alpha + pi * k == 0 (mod MOD)
MOD = 10 ** 306
alpha = (
    -648505347910123670382529605073331259247882779224489813720601031778735336734432220903925031942629071550452440266771712504122124157296394431707732489148336253799835531048552902004452234539683456985357734833579106216892269273312534671115732542721772328956123163995664215654537872416074365322209960909385719955
)
pi = 3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587
k = -alpha * pow(pi, -1, MOD) % MOD
print(f"{k=}")

M = matrix([[1, 0, -pi], [0, 1, -(10 ** 306)], [0, 0, -alpha]])
print(M.LLL())
m = -M.LLL()[0][1]
print(long_to_bytes(m))
# print(round(k).bit_length())  # 85

# -0.7578486465144361653056740883647981074157721568235263947812770328593706155446273431983003083023944193451634501133844062222318380912228469321984711771640337084400211818130699382144693337133198331117688092846455855532799303682791981067718891947573941091671581719597626862194794682042719495503282817868258547714
