from Crypto.Util.number import *
from mpmath import mp

mp.dps = 1024
eps = 1e-200


flag = int.from_bytes(open("flag.txt", "rb").read().strip(), "big")

tf = tan(flag).n(1024)
alpha = arctan(tf)
# flag == alpha + pi * k
k = (flag - alpha) / pi
assert mp.almosteq(k, round(k), eps)
# これが知りたい値
print(round(k))

# alpha の小数点以下は306桁
# 10**306 倍して整数で考える
# 10 ** 306 を法として 0 になるような k を考える
# alpha + pi * k == 0 (mod MOD)
MOD = 10 ** 306
alpha = 1140864791651824109147071749719671227963500358973913388717220459509474819742022893184973989041493689473888963699850340915813140878459524060746570927576375524770258266005308032538664078160279831876807520251892554373931981369559189285937555943274378728303667007339130248552587232952955637761230407425480377149
pi = 3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587
k = -alpha * pow(pi, -1, MOD) % MOD
print(f"{k=}")

M = matrix([[1, 0, -pi], [0, 1, -(10 ** 306)], [0, 0, -alpha]])
print(M.LLL())
m = -M.LLL()[0][1]
print(long_to_bytes(m))

# print(round(k).bit_length())  # 85

# -0.7578486465144361653056740883647981074157721568235263947812770328593706155446273431983003083023944193451634501133844062222318380912228469321984711771640337084400211818130699382144693337133198331117688092846455855532799303682791981067718891947573941091671581719597626862194794682042719495503282817868258547714
