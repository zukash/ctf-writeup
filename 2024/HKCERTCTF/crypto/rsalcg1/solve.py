from functools import reduce
from chall import LCG, get_prime
from z3 import *

a = 36355826494579817998548379553320584880009450537597708904315568847249365406149
seed = 46494514792595491123247471593699604333610389179929316013207640809301249762861
lcg = LCG(bits=256, a=a, c=0, seed=seed)
ps = [
    163279589579346313184241322315286466635372921783577196965524631268437344602010673821812897274187416681966676589353410792842055286557697197913726780203863801215355030755230211849616418558820908496084465802491391624194643798601363827687802371012888920031205047906782714633600770895269119853511567110422346358781,
    154503559218800660752610216845709842400199265314540725879414649549560365500746902303856421216340738935646277767363021967759472732300293558590270468606420372409173921407229762011306905303091803244169609964883177244998115293708530414820762560021596244715532811996971511469014715819825313535941261043110700966141,
    135361595666745743429450228832665874535877363168100168649136509884126800816849981311719283848440125785940771743128587347014795856874324030794545684823125500054033683717637686024217863549508790423741802633884501418638593703801301255131687344763519639253143518396898385619332208255837622593963509571238514566317,
    106205265094406449251844702580996947136855747426681688974057637284106203599342097143608114769541138278033788094224018206494265150176002573568976475625337597806326082842911312716874867307099460569615305157870572408283481225063049380041792848077758139122272927019993992974594421235110303881137717149990265074333,
]
n = reduce(lambda x, y: x * y, ps)
print(n.bit_length())
assert ps == [get_prime(lcg, bits=1024) for _ in range(4)]

p, q, r, s = ps
m = 1 << 256
p0 = p >> (256 * 3) & (m - 1)
q0 = q >> (256 * 3) & (m - 1)
r0 = r >> (256 * 3) & (m - 1)
s0 = s >> (256 * 3) & (m - 1)

p0q0r0s0 = (p0 * q0 * r0 * s0) >> (256 * 3)
n_head = n >> (4096 - 256)

p3 = p >> (256 * 0) & (m - 1)
q3 = q >> (256 * 0) & (m - 1)
r3 = r >> (256 * 0) & (m - 1)
s3 = s >> (256 * 0) & (m - 1)
p3q3r3s3 = (p3 * q3 * r3 * s3) >> (256 * 3)

# assert (p3 * q3 * r3 * s3) % m == n % m
# assert p3q3r3s3 == n % m
print(p0q0r0s0)
print(n % m)


p = ps[0]
m = 1 << 256
x0 = p >> (256 * 3) & (m - 1)
x1 = p >> (256 * 2) & (m - 1)
x2 = p >> (256 * 1) & (m - 1)
x3 = p >> (256 * 0) & (m - 1)

assert (x0 * a) % m == x1
assert (x1 * a) % m == x2
assert (x2 * a) % m == x3
assert (x0 * a * a) % m == x2
assert (x0 * a * a * a) % m == x3

assert p == x0 * m**3 + x1 * m**2 + x2 * m + x3
assert n % (x0 * m * m * m + x1 * m * m + x2 * m + x3) == 0

m = 1 << 256
a = 36355826494579817998548379553320584880009450537597708904315568847249365406149
s = Solver()

P = [BitVec(f"P{i}", 256) for i in range(4)]
Q = [BitVec(f"Q{i}", 256) for i in range(4)]
R = [BitVec(f"R{i}", 256) for i in range(4)]
S = [BitVec(f"S{i}", 256) for i in range(4)]

constraints = []
for X in [P, Q, R, S]:
    for i in range(3):
        constraints.append(X[i] * a == X[i + 1])

# constraints.append(
#     P[0] * Q[0] * R[0] * S[0]
#     == 114947383884015415125828042995853877039432765225323255635893433813674095035793
# )
constraints.append(P[3] * Q[3] * R[3] * S[3] == n)
constraints.append(P[0] > 1)
constraints.append(Q[0] > 1)
constraints.append(R[0] > 1)
constraints.append(S[0] > 1)
s.add(constraints)

print(s)
s.check()
model = s.model()
print(model)
