/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
void sub_1030();
void sub_1040();
void sub_1050();
void sub_1060();
void sub_1070();
void sub_1080();
void sub_1090();
void sub_10A0();
void sub_10B0();
void sub_10C0();
void sub_10D0();
void sub_10E0();
void sub_10F0();
void sub_1100();
void sub_1110();
void sub_1120();
void sub_1130();
void sub_1140();
// int __fastcall _cxa_finalize(void *);
// int putchar(int c);
// char *strcpy(char *dest, const char *src);
// int puts(const char *s);
// int printf(const char *format, ...);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void srand(unsigned int seed);
// char *fgets(char *s, int n, FILE *stream);
// int getchar(void);
// time_t time(time_t *timer);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// int open(const char *file, int oflag, ...);
// __int64 __isoc99_scanf(const char *, ...); weak
// void __noreturn exit(int status);
// unsigned int sleep(unsigned int seconds);
// int rand(void);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
void *sub_12B0();
__int64 sub_12E0();
void *sub_1320();
__int64 sub_1360();
int sub_1369();
unsigned __int64 __fastcall sub_13D8(__int64 a1, int a2);
void sub_1826();
int sub_1836();
int sub_187F();
__int64 __fastcall sub_18C8(int a1, int a2);
unsigned __int64 sub_18F2();
unsigned __int64 sub_19D2();
unsigned __int64 __fastcall sub_1D77(int a1);
unsigned __int64 sub_1E2A();
unsigned __int64 sub_1F9A();
unsigned __int64 sub_208B();
void fini(void); // idb
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN init;
const char s = '\0'; // idb
__int64 (__fastcall *off_5D30[2])() = { &sub_1360, &sub_1320 }; // weak
__int64 (__fastcall *off_5D38)() = &sub_1320; // weak
void *off_6008 = &off_6008; // idb
int dword_6050 = -17973521; // weak
_UNKNOWN unk_6058; // weak
FILE *stdout; // idb
FILE *stdin; // idb
FILE *stderr; // idb
char byte_6088; // weak
int dword_608C; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 83D0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0LL);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001030) ----------------------------------------------------
void sub_1030()
{
  sub_1020();
}

//----- (0000000000001040) ----------------------------------------------------
void sub_1040()
{
  sub_1020();
}

//----- (0000000000001050) ----------------------------------------------------
void sub_1050()
{
  sub_1020();
}

//----- (0000000000001060) ----------------------------------------------------
void sub_1060()
{
  sub_1020();
}

//----- (0000000000001070) ----------------------------------------------------
void sub_1070()
{
  sub_1020();
}

//----- (0000000000001080) ----------------------------------------------------
void sub_1080()
{
  sub_1020();
}

//----- (0000000000001090) ----------------------------------------------------
void sub_1090()
{
  sub_1020();
}

//----- (00000000000010A0) ----------------------------------------------------
void sub_10A0()
{
  sub_1020();
}

//----- (00000000000010B0) ----------------------------------------------------
void sub_10B0()
{
  sub_1020();
}

//----- (00000000000010C0) ----------------------------------------------------
void sub_10C0()
{
  sub_1020();
}

//----- (00000000000010D0) ----------------------------------------------------
void sub_10D0()
{
  sub_1020();
}

//----- (00000000000010E0) ----------------------------------------------------
void sub_10E0()
{
  sub_1020();
}

//----- (00000000000010F0) ----------------------------------------------------
void sub_10F0()
{
  sub_1020();
}

//----- (0000000000001100) ----------------------------------------------------
void sub_1100()
{
  sub_1020();
}

//----- (0000000000001110) ----------------------------------------------------
void sub_1110()
{
  sub_1020();
}

//----- (0000000000001120) ----------------------------------------------------
void sub_1120()
{
  sub_1020();
}

//----- (0000000000001130) ----------------------------------------------------
void sub_1130()
{
  sub_1020();
}

//----- (0000000000001140) ----------------------------------------------------
void sub_1140()
{
  sub_1020();
}

//----- (0000000000001280) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// 128A: positive sp value 8 has been found
// 1291: variable 'v3' is possibly undefined

//----- (00000000000012B0) ----------------------------------------------------
void *sub_12B0()
{
  return &unk_6058;
}

//----- (00000000000012E0) ----------------------------------------------------
__int64 sub_12E0()
{
  return 0LL;
}

//----- (0000000000001320) ----------------------------------------------------
void *sub_1320()
{
  void *result; // rax

  if ( !byte_6088 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_6008);
    result = sub_12B0();
    byte_6088 = 1;
  }
  return result;
}
// 6088: using guessed type char byte_6088;

//----- (0000000000001360) ----------------------------------------------------
// attributes: thunk
__int64 sub_1360()
{
  return sub_12E0();
}

//----- (0000000000001369) ----------------------------------------------------
int sub_1369()
{
  alarm(0x3Cu);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  return setvbuf(stderr, 0LL, 2, 0LL);
}

//----- (00000000000013D8) ----------------------------------------------------
unsigned __int64 __fastcall sub_13D8(__int64 a1, int a2)
{
  __int64 *v2; // rax
  __int64 *v3; // rdx
  __int64 v4; // rbx
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rbx
  int i; // [rsp+18h] [rbp-E8h]
  int v18; // [rsp+1Ch] [rbp-E4h]
  __int64 v19; // [rsp+20h] [rbp-E0h]
  __int64 v20; // [rsp+28h] [rbp-D8h]
  __int64 v21; // [rsp+30h] [rbp-D0h]
  __int64 v22; // [rsp+38h] [rbp-C8h]
  __int64 v23; // [rsp+40h] [rbp-C0h]
  __int64 v24; // [rsp+48h] [rbp-B8h]
  __int64 v25; // [rsp+50h] [rbp-B0h]
  __int64 v26; // [rsp+58h] [rbp-A8h]
  __int64 v27; // [rsp+60h] [rbp-A0h]
  __int64 v28; // [rsp+68h] [rbp-98h]
  __int64 v29; // [rsp+70h] [rbp-90h]
  __int64 v30; // [rsp+78h] [rbp-88h]
  __int64 v31; // [rsp+80h] [rbp-80h]
  __int64 v32; // [rsp+88h] [rbp-78h]
  __int64 v33; // [rsp+90h] [rbp-70h]
  __int64 v34; // [rsp+98h] [rbp-68h]
  __int64 v35; // [rsp+A0h] [rbp-60h]
  __int64 v36; // [rsp+A8h] [rbp-58h]
  __int64 v37; // [rsp+B0h] [rbp-50h]
  __int64 v38; // [rsp+B8h] [rbp-48h]
  __int64 v39; // [rsp+C0h] [rbp-40h]
  __int64 v40; // [rsp+C8h] [rbp-38h]
  __int64 v41; // [rsp+D0h] [rbp-30h]
  __int64 v42; // [rsp+D8h] [rbp-28h]
  __int64 v43; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v44; // [rsp+E8h] [rbp-18h]

  v44 = __readfsqword(0x28u);
  for ( i = a2 - 1; i > 0; --i )
  {
    v18 = rand() % (i + 1);
    v2 = (__int64 *)(200LL * i + a1);
    v19 = *v2;
    v20 = v2[1];
    v21 = v2[2];
    v22 = v2[3];
    v23 = v2[4];
    v24 = v2[5];
    v25 = v2[6];
    v26 = v2[7];
    v27 = v2[8];
    v28 = v2[9];
    v29 = v2[10];
    v30 = v2[11];
    v31 = v2[12];
    v32 = v2[13];
    v33 = v2[14];
    v34 = v2[15];
    v35 = v2[16];
    v36 = v2[17];
    v37 = v2[18];
    v38 = v2[19];
    v39 = v2[20];
    v40 = v2[21];
    v41 = v2[22];
    v42 = v2[23];
    v43 = v2[24];
    v3 = (__int64 *)(a1 + 200LL * v18);
    v4 = v3[1];
    *v2 = *v3;
    v2[1] = v4;
    v5 = v3[3];
    v2[2] = v3[2];
    v2[3] = v5;
    v6 = v3[5];
    v2[4] = v3[4];
    v2[5] = v6;
    v7 = v3[7];
    v2[6] = v3[6];
    v2[7] = v7;
    v8 = v3[9];
    v2[8] = v3[8];
    v2[9] = v8;
    v9 = v3[11];
    v2[10] = v3[10];
    v2[11] = v9;
    v10 = v3[13];
    v2[12] = v3[12];
    v2[13] = v10;
    v11 = v3[15];
    v2[14] = v3[14];
    v2[15] = v11;
    v12 = v3[17];
    v2[16] = v3[16];
    v2[17] = v12;
    v13 = v3[19];
    v2[18] = v3[18];
    v2[19] = v13;
    v14 = v3[21];
    v2[20] = v3[20];
    v2[21] = v14;
    v15 = v3[23];
    v2[22] = v3[22];
    v2[23] = v15;
    v2[24] = v3[24];
    *v3 = v19;
    v3[1] = v20;
    v3[2] = v21;
    v3[3] = v22;
    v3[4] = v23;
    v3[5] = v24;
    v3[6] = v25;
    v3[7] = v26;
    v3[8] = v27;
    v3[9] = v28;
    v3[10] = v29;
    v3[11] = v30;
    v3[12] = v31;
    v3[13] = v32;
    v3[14] = v33;
    v3[15] = v34;
    v3[16] = v35;
    v3[17] = v36;
    v3[18] = v37;
    v3[19] = v38;
    v3[20] = v39;
    v3[21] = v40;
    v3[22] = v41;
    v3[23] = v42;
    v3[24] = v43;
  }
  return __readfsqword(0x28u) ^ v44;
}

//----- (0000000000001826) ----------------------------------------------------
void sub_1826()
{
  ;
}

//----- (0000000000001836) ----------------------------------------------------
int sub_1836()
{
  puts(&s);
  printf(
    "%s%s%s\n",
    "\x1B[38;5;229m",
    "       ______ ______      \n"
    "     _/      Y      \\_    \n"
    "    // ~~ ~~ | ~~ ~  \\\\   \n"
    "   // ~ ~ ~~ | ~~~ ~~ \\\\  \n"
    "  //________.|.________\\\\ \n"
    " `----------'-'----------'",
    "\x1B[0m");
  return puts(&s);
}

//----- (000000000000187F) ----------------------------------------------------
int sub_187F()
{
  puts(&s);
  printf(
    "%s%s%s\n",
    "\x1B[31m",
    "    ____________________  \n"
    "   /                    \\ \n"
    "   |      WE'RE OUT     |  \n"
    "   |      OF STOCK.     |  \n"
    "   \\___________________/  \n"
    "           !  ! \n"
    "           L_ ! \n"
    "          / _)! \n"
    "         / /_ L \n"
    "   _____/ (____) \n"
    "          (____) \n"
    "   _____  (____) \n"
    "        \\_(____) \n"
    "           !  ! \n"
    "           \\__/ \n",
    "\x1B[0m");
  return puts(&s);
}

//----- (00000000000018C8) ----------------------------------------------------
__int64 __fastcall sub_18C8(int a1, int a2)
{
  return (unsigned int)(rand() % (a2 - a1 + 1) + a1);
}

//----- (00000000000018F2) ----------------------------------------------------
unsigned __int64 sub_18F2()
{
  unsigned int v0; // eax
  int v2; // [rsp+Ch] [rbp-34h]
  const char *i; // [rsp+10h] [rbp-30h]
  __int64 v4[3]; // [rsp+20h] [rbp-20h]
  unsigned __int64 v5; // [rsp+38h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v4[0] = (__int64)"\x1B[32m";
  v4[1] = (__int64)"\x1B[35m";
  v0 = time(0LL);
  srand(v0);
  for ( i = "                  .----.   \n"
            "      .---------. | == |   \n"
            "      |.-\"\"\"\"\"-.| |----|   \n"
            "      ||       || | == |   \n"
            "      ||       || |----|   \n"
            "      |'-.....-'| |::::|   \n"
            "      `\"\")---(\"\"` |___.|   \n"
            "     /:::::::::::\\\" _  \"   \n"
            "    /:::=======:::\\`\\`\\   \n"
            "    `\"\"\"\"\"\"\"\"\"\"\"\"\"`  '-'   \n"; *i; ++i )
  {
    if ( *i == 10 )
    {
      putchar(*i);
    }
    else
    {
      v2 = sub_18C8(0, 1);
      printf("%s%c\x1B[0m", (const char *)v4[v2], (unsigned int)*i);
    }
  }
  return __readfsqword(0x28u) ^ v5;
}

//----- (00000000000019D2) ----------------------------------------------------
unsigned __int64 sub_19D2()
{
  unsigned int v0; // eax
  int i; // [rsp+8h] [rbp-BE8h]
  int j; // [rsp+Ch] [rbp-BE4h]
  char *src[14]; // [rsp+10h] [rbp-BE0h]
  char *v5[14]; // [rsp+80h] [rbp-B70h]
  char v6[2808]; // [rsp+F0h] [rbp-B00h] BYREF
  unsigned __int64 v7; // [rsp+BE8h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  src[0] = "Artificial Intelligence: A Modern Approach";
  src[1] = "Superintelligence: Paths, Dangers, Strategies";
  src[2] = "AI Superpowers: China, Silicon Valley, and the New World Order";
  src[3] = "The Singularity Is Near: When Humans Transcend Biology";
  src[4] = "AI Ethics";
  src[5] = "The Fourth Age: Smart Robots, Conscious Computers, and the Future of Humanity";
  src[6] = "I Am A Strange Loop";
  src[7] = "Machines Like Me";
  src[8] = "Heartificial Intelligence: Embracing Our Humanity to Maximize Machines";
  src[9] = "Life's Ratchet: How Molecular Machines Extract Order from Chaos";
  src[10] = "The Sentient Machine: The Coming Age of Artificial Intelligence";
  src[11] = "Robot-Proof: Higher Education in the Age of Artificial Intelligence";
  src[12] = "AIQ: How People and Machines Are Smarter Together";
  src[13] = "Thinking Machines: The Quest for Artificial Intelligence and Where It's Taking Us Next";
  v5[0] = "Stuart Russell, Peter Norvig";
  v5[1] = "Nick Bostrom";
  v5[2] = "Kai-Fu Lee";
  v5[3] = "Ray Kurzweil";
  v5[4] = "Wendell Wallach, Colin Allen";
  v5[5] = "Byron Reese";
  v5[6] = "Douglas Hofstadter";
  v5[7] = "Ian McEwan";
  v5[8] = "John C. Havens";
  v5[9] = "Peter M. Hoffmann";
  v5[10] = "Amir Husain";
  v5[11] = "Joseph E. Aoun";
  v5[12] = "Nick Polson, James Scott";
  v5[13] = "Luke Dormehl";
  for ( i = 0; i <= 13; ++i )
  {
    strcpy(&v6[200 * i], src[i]);
    strcpy(&v6[200 * i + 100], v5[i]);
  }
  v0 = time(0LL);
  srand(v0);
  sub_13D8((__int64)v6, 14);
  puts(&s);
  printf("%s[LIST OF BOOKS]:%s\n", "\x1B[36m", "\x1B[0m");
  puts(&s);
  for ( j = 0; j <= 13; ++j )
    printf("[+] %s by %s\n", &v6[200 * j], &v6[200 * j + 100]);
  puts(&s);
  printf("%s[>] Press enter to return to menu..%s\n", "\x1B[33m", "\x1B[0m");
  getchar();
  puts(&s);
  return __readfsqword(0x28u) ^ v7;
}
// 19D2: using guessed type char var_B00[2808];

//----- (0000000000001D77) ----------------------------------------------------
unsigned __int64 __fastcall sub_1D77(int a1)
{
  char s[104]; // [rsp+10h] [rbp-70h] BYREF
  unsigned __int64 v3; // [rsp+78h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  sub_18F2();
  if ( a1 == 2 )
  {
    printf("%s[/] UNDER DEVELOPMENT %s\n", "\x1B[44m", "\x1B[0m");
    putchar(62);
    fgets(s, 160, stdin);
  }
  else
  {
    printf("%s[!] SECURITY BREACH DETECTED%s\n", "\x1B[41m", "\x1B[0m");
    puts("[+] BAD HACKER!!");
  }
  return __readfsqword(0x28u) ^ v3;
}
// 1D77: using guessed type char s[104];

//----- (0000000000001E2A) ----------------------------------------------------
unsigned __int64 sub_1E2A()
{
  char v1; // [rsp+7h] [rbp-59h] BYREF
  int buf; // [rsp+8h] [rbp-58h] BYREF
  int fd; // [rsp+Ch] [rbp-54h]
  char s[72]; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v5; // [rsp+58h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  fd = open("/dev/urandom", 0);
  read(fd, &buf, 4uLL);
  close(fd);
  buf = (unsigned __int16)buf;
  do
  {
    printf("Enter book title: ");
    fgets(s, 50, stdin);
    printf("Book title --> ");
    // NOTE: 書式文字列攻撃
    printf(s);
    puts(&::s);
    if ( 334873123 * buf == dword_6050 )
    {
      dword_608C = 2;
      sub_1D77(2);
    }
    puts("Sorry, we already have the same title as yours in our database; give me another book title.");
    printf("Still interested in selling your book? [y/n]: ");
    __isoc99_scanf("%1c", &v1);
    getchar();
  }
  while ( v1 == 121 );
  puts(&::s);
  printf("%s[-] Exiting program..%s\n", "\x1B[31m", "\x1B[0m");
  sleep(1u);
  return __readfsqword(0x28u) ^ v5;
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);
// 6050: using guessed type int dword_6050;
// 608C: using guessed type int dword_608C;

//----- (0000000000001F9A) ----------------------------------------------------
unsigned __int64 sub_1F9A()
{
  char v1; // [rsp+Fh] [rbp-71h] BYREF
  char s[104]; // [rsp+10h] [rbp-70h] BYREF
  unsigned __int64 v3; // [rsp+78h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  sub_187F();
  printf(
    "%sSorry, there are no books to buy at this time, but you can request a book if you want.%s\n",
    "\x1B[34m",
    "\x1B[0m");
  printf("Want to request a book?? ");
  printf("[y/n]: ");
  __isoc99_scanf("%1c", &v1);
  getchar();
  if ( v1 == 121 )
  {
    printf("Enter book title: ");
    fgets(s, 50, stdin);
    puts("Ok! Thankyou! Our research team shall considered that book.");
  }
  else
  {
    puts("Alright then..");
    puts(&::s);
  }
  return __readfsqword(0x28u) ^ v3;
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);
// 1F9A: using guessed type char s[104];

//----- (000000000000208B) ----------------------------------------------------
unsigned __int64 sub_208B()
{
  int v1; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  do
  {
    puts(" +=======================+");
    puts(" |                       |");
    puts(" |     IMG BOOKSTORE     |");
    puts(" |                       |");
    puts(" +=-=-=-=-=-=-=-=-=-=-=-=+");
    puts(" |                       |");
    puts(" | [1]. List Books.      |");
    puts(" | [2]. Buy Book.        |");
    puts(" | [3]. Sell Book.       |");
    puts(" | [4]. Exit.            |");
    puts(" |                       |");
    puts(" +=======================+");
    puts(&s);
    printf(">> ");
    __isoc99_scanf("%1d", &v1);
    getchar();
    if ( v1 == 4 )
    {
      puts(&s);
      printf("%s[-] Exiting program..%s\n", "\x1B[31m", "\x1B[0m");
      sleep(1u);
      exit(0);
    }
    if ( v1 <= 4 )
    {
      switch ( v1 )
      {
        case 3:
          sub_1E2A();
          continue;
        case 1:
          sub_19D2();
          continue;
        case 2:
          sub_1F9A();
          continue;
      }
    }
    printf("%s[/] Invalid option..%s\n", "\x1B[33m", "\x1B[0m");
    puts(&s);
  }
  while ( v1 != 3 );
  return __readfsqword(0x28u) ^ v2;
}
// 2185: conditional instruction was optimized away because %var_C.4<3
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);

//----- (0000000000002248) ----------------------------------------------------
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  sub_1369();
  puts(&s);
  printf("%s[+] Please wait.. The program is starting..%s\n", "\x1B[32m", "\x1B[0m");
  sleep(1u);
  sub_1836();
  sub_208B();
  return 0LL;
}

//----- (00000000000022B0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  init_proc();
  v4 = &off_5D38 - off_5D30;
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_5D30[i])(a1, a2, a3);
  }
}
// 5D30: using guessed type __int64 (__fastcall *off_5D30[2])();
// 5D38: using guessed type __int64 (__fastcall *off_5D38)();

//----- (0000000000002320) ----------------------------------------------------
void fini(void)
{
  ;
}

//----- (0000000000002328) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=81 queued=41 decompiled=41 lumina nreq=0 worse=0 better=0
// ALL OK, 41 function(s) have been successfully decompiled
